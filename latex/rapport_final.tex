\documentclass[12pt,a4paper]{report}

% === Packages ===
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{float}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{longtable}
\usepackage{appendix}

% === Configuration de la page ===
\geometry{margin=2.5cm, top=3cm, bottom=3cm}

% === Configuration des liens ===
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black
}

% === Configuration du code source ===
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    tabsize=4,
    numbers=left,
    numbersep=8pt,
    showstringspaces=false
}
\lstset{style=mystyle}

% === En-tête et pied de page ===
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{Détection de Communautés}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% === Configuration des chapitres ===
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-20pt}{40pt}

% === Début du document ===
\begin{document}

% ============================================================================
% PAGE DE GARDE
% ============================================================================
\begin{titlepage}
    \centering
    
    % Logo et université
    \begin{figure}[H]
        \centering
        % Décommenter et ajuster le chemin quand vous avez le logo
        % \includegraphics[width=4cm]{logo_fst_tanger.png}
        \vspace{1cm}
        
        % Placeholder pour le logo
        \fbox{\parbox{4cm}{\centering\vspace{1cm}\textbf{Logo FST Tanger}\vspace{1cm}}}
    \end{figure}
    
    \vspace{0.5cm}
    
    {\Large\textbf{Université Abdelmalek Essaâdi}}\\[0.3cm]
    {\large Faculté des Sciences et Techniques de Tanger}\\[0.3cm]
    {\large Département Génie Informatique}\\[0.5cm]
    
    \rule{\textwidth}{1pt}\\[0.5cm]
    
    {\large\textbf{Licence : Analytique des Données}}\\[1.5cm]
    
    % Titre du projet
    {\huge\textbf{Rapport de Projet}}\\[0.5cm]
    {\LARGE\textbf{Structure de Données}}\\[1cm]
    
    \rule{0.8\textwidth}{2pt}\\[0.5cm]
    
    {\Huge\textbf{Détection de Sous-Groupes\\dans un Réseau d'Amis}}\\[0.5cm]
    
    \rule{0.8\textwidth}{2pt}\\[2cm]
    
    % Préparé par et Encadré par
    \begin{minipage}[t]{0.45\textwidth}
        \begin{flushleft}
            {\large\textbf{Préparé par :}}\\[0.3cm]
            {\large Nom Prénom}\\
            {\large Nom Prénom}\\
            % Ajouter d'autres noms si nécessaire
        \end{flushleft}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\textwidth}
        \begin{flushright}
            {\large\textbf{Encadré par :}}\\[0.3cm]
            {\large Prof. Ouafae Baida}\\
        \end{flushright}
    \end{minipage}
    
    \vfill
    
    \rule{\textwidth}{1pt}\\[0.3cm]
    {\large\textbf{Année Universitaire : 2025 / 2026}}
    
\end{titlepage}

% ============================================================================
% TABLES DES MATIÈRES
% ============================================================================
\pagenumbering{roman}

% Table des matières
\tableofcontents
\newpage

% Table des figures
\listoffigures
\addcontentsline{toc}{chapter}{Table des Figures}
\newpage

% Table des tableaux
\listoftables
\addcontentsline{toc}{chapter}{Liste des Tableaux}
\newpage

% ============================================================================
% CONTENU PRINCIPAL
% ============================================================================
\pagenumbering{arabic}

% ============================================================================
\chapter{Introduction}
% ============================================================================

\section{Contexte du Projet}

Dans le cadre de notre formation en \textbf{Licence Analytique des Données} à la Faculté des Sciences et Techniques de Tanger, nous avons réalisé un projet portant sur la \textbf{détection de sous-groupes} (communautés) dans un réseau social d'amis.

Les réseaux sociaux sont omniprésents dans notre quotidien. Comprendre leur structure et identifier les groupes cohérents qui les composent est un enjeu majeur pour de nombreuses applications : recommandation d'amis, détection de communautés d'intérêt, analyse marketing, etc.

\section{Problématique}

Comment identifier automatiquement des groupes d'amis cohérents dans un réseau social où les relations sont représentées sous forme de graphe ?

\section{Objectifs}

Les objectifs de ce projet sont :

\begin{enumerate}
    \item Construire un graphe représentant un réseau d'amis à partir de données CSV
    \item Implémenter et appliquer deux algorithmes de détection de communautés
    \item Comparer les performances des algorithmes (Louvain vs Girvan-Newman)
    \item Visualiser les résultats de manière graphique
    \item Analyser les relations internes et externes des communautés détectées
    \item Développer une interface web interactive
\end{enumerate}

\section{Technologies Utilisées}

\begin{table}[H]
    \centering
    \caption{Technologies et bibliothèques utilisées}
    \label{tab:technologies}
    \begin{tabular}{|l|l|p{7cm}|}
        \hline
        \textbf{Technologie} & \textbf{Version} & \textbf{Usage} \\
        \hline
        Python & 3.x & Langage de programmation principal \\
        \hline
        NetworkX & $\geq$ 3.0 & Manipulation et analyse de graphes \\
        \hline
        python-louvain & $\geq$ 0.16 & Implémentation de l'algorithme Louvain \\
        \hline
        Matplotlib & $\geq$ 3.7 & Visualisation graphique \\
        \hline
        Pandas & $\geq$ 2.0 & Manipulation des données CSV \\
        \hline
        HTML/CSS/JS & - & Interface web interactive \\
        \hline
        Vis.js & - & Visualisation de graphes dans le navigateur \\
        \hline
    \end{tabular}
\end{table}

% ============================================================================
\chapter{Concepts Théoriques}
% ============================================================================

\section{Représentation en Graphe}

Un réseau social peut être modélisé comme un \textbf{graphe non orienté} $G = (V, E)$ où :

\begin{itemize}
    \item $V$ = ensemble des \textbf{sommets} (utilisateurs)
    \item $E$ = ensemble des \textbf{arêtes} (relations d'amitié)
\end{itemize}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.6\textwidth]{graphe_exemple.png}
    \fbox{\parbox{0.6\textwidth}{\centering\vspace{2cm}Exemple de graphe\\(Image à ajouter)\vspace{2cm}}}
    \caption{Exemple de graphe représentant un réseau d'amis}
    \label{fig:graphe_exemple}
\end{figure}

\section{Notion de Communauté}

Une \textbf{communauté} est un sous-ensemble de nœuds qui sont :
\begin{itemize}
    \item Densément connectés entre eux (beaucoup de liens internes)
    \item Faiblement connectés au reste du réseau (peu de liens externes)
\end{itemize}

\section{La Modularité}

La \textbf{modularité} $Q$ est une mesure de la qualité d'une partition en communautés. Elle compare la densité de liens à l'intérieur des communautés par rapport à une distribution aléatoire des liens.

\begin{equation}
    Q = \frac{1}{2m} \sum_{ij} \left[ A_{ij} - \frac{k_i k_j}{2m} \right] \delta(c_i, c_j)
    \label{eq:modularite}
\end{equation}

Où :
\begin{itemize}
    \item $A_{ij}$ = élément de la matrice d'adjacence (1 si lien, 0 sinon)
    \item $k_i$ = degré du nœud $i$ (nombre de connexions)
    \item $m$ = nombre total d'arêtes dans le graphe
    \item $c_i$ = communauté du nœud $i$
    \item $\delta(c_i, c_j)$ = 1 si $c_i = c_j$, 0 sinon (fonction delta de Kronecker)
\end{itemize}

\textbf{Interprétation :}
\begin{itemize}
    \item $Q \approx 1$ : excellente séparation en communautés
    \item $Q \approx 0$ : partition aléatoire, pas de structure communautaire
    \item $Q < 0$ : pire qu'une partition aléatoire
    \item En pratique, $Q > 0.3$ indique une bonne structure de communautés
\end{itemize}

\section{Algorithme de Louvain}

L'algorithme de Louvain est une méthode \textbf{agglomérative} (bottom-up) développée par Blondel et al. en 2008.

\subsection{Principe}

\begin{enumerate}
    \item \textbf{Initialisation} : Chaque nœud forme sa propre communauté (n communautés)
    \item \textbf{Phase 1 - Optimisation locale} : 
    \begin{itemize}
        \item Pour chaque nœud, calculer le gain de modularité si on le déplace vers une communauté voisine
        \item Effectuer le déplacement qui maximise le gain
        \item Répéter jusqu'à ce qu'aucun déplacement n'améliore la modularité
    \end{itemize}
    \item \textbf{Phase 2 - Agrégation} : 
    \begin{itemize}
        \item Fusionner les nœuds d'une même communauté en un "super-nœud"
        \item Construire un nouveau graphe avec ces super-nœuds
    \end{itemize}
    \item \textbf{Répétition} : Retourner à la Phase 1 sur le nouveau graphe
\end{enumerate}

\subsection{Complexité}

\begin{itemize}
    \item Complexité temporelle : $O(n \log n)$ en moyenne
    \item Très efficace sur de grands graphes (millions de nœuds)
\end{itemize}

\begin{table}[H]
    \centering
    \caption{Avantages et inconvénients de l'algorithme Louvain}
    \label{tab:louvain_avantages}
    \begin{tabular}{|p{6cm}|p{6cm}|}
        \hline
        \textbf{Avantages} & \textbf{Inconvénients} \\
        \hline
        Très rapide & Peut manquer de petites communautés \\
        \hline
        Bons résultats en pratique & Résultats non déterministes \\
        \hline
        Trouve automatiquement le nombre optimal de communautés & Peut créer des "super-communautés" \\
        \hline
    \end{tabular}
\end{table}

\section{Algorithme de Girvan-Newman}

L'algorithme de Girvan-Newman est une méthode \textbf{divisive} (top-down) développée par Girvan et Newman en 2002.

\subsection{Principe}

\begin{enumerate}
    \item \textbf{Initialisation} : Tout le graphe forme une seule communauté
    \item \textbf{Calcul de la centralité d'intermédiarité} (edge betweenness) :
    \begin{itemize}
        \item Pour chaque arête, compter le nombre de plus courts chemins qui la traversent
        \item L'arête avec la plus grande centralité est un "pont" entre communautés
    \end{itemize}
    \item \textbf{Suppression} : Supprimer l'arête avec la plus grande centralité
    \item \textbf{Répétition} : Recalculer les centralités et répéter jusqu'à obtenir le nombre de communautés souhaité
\end{enumerate}

\subsection{Complexité}

\begin{itemize}
    \item Complexité temporelle : $O(m^2 n)$ où $m$ = arêtes, $n$ = nœuds
    \item Plus lent que Louvain, adapté aux petits/moyens graphes
\end{itemize}

\begin{table}[H]
    \centering
    \caption{Avantages et inconvénients de l'algorithme Girvan-Newman}
    \label{tab:gn_avantages}
    \begin{tabular}{|p{6cm}|p{6cm}|}
        \hline
        \textbf{Avantages} & \textbf{Inconvénients} \\
        \hline
        Détecte bien les "ponts" entre groupes & Plus lent que Louvain \\
        \hline
        Contrôle du nombre de communautés & Doit choisir le nombre de communautés \\
        \hline
        Résultats déterministes & Coûteux en calcul pour grands graphes \\
        \hline
    \end{tabular}
\end{table}

% ============================================================================
\chapter{Architecture du Projet}
% ============================================================================

\section{Structure des Dossiers}

\begin{lstlisting}[language=bash, caption=Structure du projet]
Projet-Structure-15/
|
|-- data/
|   +-- reseau_amis.csv          # Donnees du reseau
|
|-- src/
|   |-- graphe.py                # Construction du graphe
|   |-- louvain.py               # Algorithme Louvain
|   |-- girvan_newman.py         # Algorithme Girvan-Newman
|   |-- comparaison.py           # Comparaison des algorithmes
|   |-- visualisation.py         # Visualisation graphique
|   +-- analyse.py               # Analyse des communautes
|
|-- interface/
|   |-- index.html               # Page web
|   |-- style.css                # Styles CSS
|   +-- app.js                   # Logique JavaScript
|
|-- resultats/                   # Images generees
|-- latex/                       # Rapport LaTeX
|-- main.py                      # Point d'entree
+-- requirements.txt             # Dependances Python
\end{lstlisting}

\section{Description des Modules}

\subsection{Module graphe.py}

Ce module est responsable du chargement des données et de la construction du graphe.

\begin{table}[H]
    \centering
    \caption{Fonctions du module graphe.py}
    \label{tab:fonctions_graphe}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{charger\_donnees(chemin)} & Charge le fichier CSV contenant les relations \\
        \hline
        \texttt{construire\_graphe(df)} & Construit un graphe NetworkX à partir du DataFrame \\
        \hline
        \texttt{afficher\_informations\_graphe(G)} & Affiche les statistiques du graphe \\
        \hline
        \texttt{charger\_graphe\_complet(chemin)} & Combine chargement et construction \\
        \hline
    \end{tabular}
\end{table}

\subsection{Module louvain.py}

Implémentation de la détection de communautés avec l'algorithme de Louvain.

\begin{table}[H]
    \centering
    \caption{Fonctions du module louvain.py}
    \label{tab:fonctions_louvain}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{detecter\_communautes(G)} & Applique l'algorithme Louvain \\
        \hline
        \texttt{calculer\_modularite(G, partition)} & Calcule la modularité \\
        \hline
        \texttt{obtenir\_communautes(partition)} & Convertit en liste de sets \\
        \hline
        \texttt{afficher\_communautes(partition)} & Affiche les résultats \\
        \hline
        \texttt{executer\_louvain(G)} & Fonction principale \\
        \hline
    \end{tabular}
\end{table}

\subsection{Module girvan\_newman.py}

Implémentation de la détection de communautés avec l'algorithme de Girvan-Newman.

\begin{table}[H]
    \centering
    \caption{Fonctions du module girvan\_newman.py}
    \label{tab:fonctions_gn}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{detecter\_communautes(G, k)} & Applique Girvan-Newman pour k communautés \\
        \hline
        \texttt{calculer\_modularite(G, comm)} & Calcule la modularité \\
        \hline
        \texttt{convertir\_en\_partition(comm)} & Convertit en dictionnaire \\
        \hline
        \texttt{executer\_girvan\_newman(G, k)} & Fonction principale \\
        \hline
    \end{tabular}
\end{table}

\subsection{Module comparaison.py}

Compare les deux algorithmes selon plusieurs métriques.

\begin{table}[H]
    \centering
    \caption{Fonctions du module comparaison.py}
    \label{tab:fonctions_comparaison}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{mesurer\_temps(fonction, *args)} & Mesure le temps d'exécution \\
        \hline
        \texttt{comparer\_algorithmes(G, k)} & Compare Louvain et Girvan-Newman \\
        \hline
        \texttt{afficher\_comparaison(resultats)} & Affiche le tableau comparatif \\
        \hline
    \end{tabular}
\end{table}

\subsection{Module visualisation.py}

Génère les visualisations graphiques.

\begin{table}[H]
    \centering
    \caption{Fonctions du module visualisation.py}
    \label{tab:fonctions_visualisation}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{dessiner\_graphe\_simple(G)} & Dessine le graphe original \\
        \hline
        \texttt{dessiner\_communautes(G, partition)} & Dessine avec couleurs par communauté \\
        \hline
        \texttt{dessiner\_comparaison(...)} & Comparaison côte à côte \\
        \hline
        \texttt{sauvegarder\_image(fig, nom)} & Sauvegarde en PNG \\
        \hline
    \end{tabular}
\end{table}

\subsection{Module analyse.py}

Analyse les communautés détectées (relations internes/externes).

\begin{table}[H]
    \centering
    \caption{Fonctions du module analyse.py}
    \label{tab:fonctions_analyse}
    \begin{tabular}{|l|p{8cm}|}
        \hline
        \textbf{Fonction} & \textbf{Description} \\
        \hline
        \texttt{compter\_aretes\_internes(G, membres)} & Compte les liens internes \\
        \hline
        \texttt{compter\_aretes\_externes(G, membres)} & Compte les liens externes \\
        \hline
        \texttt{calculer\_densite(G, membres)} & Calcule la densité \\
        \hline
        \texttt{analyser\_toutes\_communautes(G, comm)} & Analyse complète \\
        \hline
    \end{tabular}
\end{table}

% ============================================================================
\chapter{Implémentation}
% ============================================================================

\section{Format des Données}

Les données d'entrée sont au format CSV avec deux colonnes représentant les relations d'amitié :

\begin{lstlisting}[caption=Format du fichier CSV]
utilisateur1,utilisateur2
Alice,Bob
Alice,Charlie
Bob,Charlie
Emma,Fanny
...
\end{lstlisting}

Notre jeu de données de test contient :
\begin{itemize}
    \item \textbf{20 utilisateurs} (nœuds)
    \item \textbf{5 communautés naturelles} de 4 personnes chacune
    \item \textbf{8 connexions "ponts"} entre les communautés
\end{itemize}

\section{Construction du Graphe}

\begin{lstlisting}[language=Python, caption=Extrait de graphe.py]
import pandas as pd
import networkx as nx

def charger_donnees(chemin_csv):
    """Charge les relations d'amitie depuis un fichier CSV."""
    df = pd.read_csv(chemin_csv)
    print(f"Donnees chargees: {len(df)} relations trouvees")
    return df

def construire_graphe(df):
    """Construit le graphe a partir des donnees."""
    G = nx.Graph()
    
    for i in range(len(df)):
        ami1 = df.loc[i, 'utilisateur1']
        ami2 = df.loc[i, 'utilisateur2']
        G.add_edge(ami1, ami2)
    
    print(f"Graphe construit: {G.number_of_nodes()} noeuds")
    return G
\end{lstlisting}

\section{Détection avec Louvain}

\begin{lstlisting}[language=Python, caption=Extrait de louvain.py]
import community  # python-louvain

def detecter_communautes(G):
    """Applique l'algorithme de Louvain."""
    partition = community.best_partition(G)
    return partition

def calculer_modularite(G, partition):
    """Calcule la modularite de la partition."""
    modularite = community.modularity(partition, G)
    return modularite
\end{lstlisting}

\section{Détection avec Girvan-Newman}

\begin{lstlisting}[language=Python, caption=Extrait de girvan\_newman.py]
import networkx as nx
from networkx.algorithms.community import girvan_newman

def detecter_communautes(G, k=None):
    """Applique l'algorithme de Girvan-Newman."""
    comp = girvan_newman(G)
    
    if k is not None:
        for communautes in comp:
            if len(communautes) >= k:
                return [set(c) for c in communautes]
    
    return list(communautes)
\end{lstlisting}

\section{Analyse des Communautés}

\begin{lstlisting}[language=Python, caption=Extrait de analyse.py]
def compter_aretes_internes(G, membres):
    """Compte les aretes dans une communaute."""
    count = 0
    for u, v in G.edges():
        if u in membres and v in membres:
            count += 1
    return count

def calculer_densite(G, membres):
    """Calcule la densite d'une communaute."""
    n = len(membres)
    if n < 2:
        return 0.0
    aretes_possibles = n * (n - 1) / 2
    aretes_existantes = compter_aretes_internes(G, membres)
    return aretes_existantes / aretes_possibles
\end{lstlisting}

% ============================================================================
\chapter{Résultats et Analyse}
% ============================================================================

\section{Résultats de la Détection}

Les deux algorithmes ont été appliqués sur notre jeu de données de 20 utilisateurs.

\begin{table}[H]
    \centering
    \caption{Comparaison des algorithmes}
    \label{tab:comparaison_resultats}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Métrique} & \textbf{Louvain} & \textbf{Girvan-Newman} \\
        \hline
        Complexité & $O(n \log n)$ & $O(m^2 n)$ \\
        \hline
        Modularité & $\approx 0.65$ & $\approx 0.62$ \\
        \hline
        Nombre de communautés & 5 & 5 \\
        \hline
        Taille moyenne & 4.0 & 4.0 \\
        \hline
        Temps d'exécution & $\approx 0.002$ s & $\approx 0.05$ s \\
        \hline
    \end{tabular}
\end{table}

\section{Visualisation des Communautés}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{../resultats/graphe_louvain.png}
    \fbox{\parbox{0.8\textwidth}{\centering\vspace{4cm}Visualisation Louvain\\(Image générée par le programme)\vspace{4cm}}}
    \caption{Communautés détectées par l'algorithme de Louvain}
    \label{fig:louvain}
\end{figure}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{../resultats/graphe_girvan_newman.png}
    \fbox{\parbox{0.8\textwidth}{\centering\vspace{4cm}Visualisation Girvan-Newman\\(Image générée par le programme)\vspace{4cm}}}
    \caption{Communautés détectées par l'algorithme de Girvan-Newman}
    \label{fig:girvan_newman}
\end{figure}

\section{Analyse des Relations Internes/Externes}

\begin{table}[H]
    \centering
    \caption{Analyse des communautés (exemple avec Louvain)}
    \label{tab:analyse_communautes}
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Communauté} & \textbf{Taille} & \textbf{Arêtes Int.} & \textbf{Arêtes Ext.} & \textbf{Densité} \\
        \hline
        Communauté 1 & 4 & 6 & 2 & 1.00 \\
        \hline
        Communauté 2 & 4 & 6 & 2 & 1.00 \\
        \hline
        Communauté 3 & 4 & 6 & 2 & 1.00 \\
        \hline
        Communauté 4 & 4 & 6 & 2 & 1.00 \\
        \hline
        Communauté 5 & 4 & 6 & 0 & 1.00 \\
        \hline
    \end{tabular}
\end{table}

\section{Interprétation}

\begin{itemize}
    \item \textbf{Modularité élevée} ($Q \approx 0.65$) : Les communautés sont bien séparées
    \item \textbf{Densité = 1.00} : Chaque groupe est un graphe complet (tous connectés entre eux)
    \item \textbf{Peu de liens externes} : Les communautés sont relativement isolées
    \item \textbf{Louvain plus rapide} : Environ 25x plus rapide que Girvan-Newman sur ce jeu de données
\end{itemize}

% ============================================================================
\chapter{Interface Web}
% ============================================================================

\section{Fonctionnalités}

L'interface web permet de :

\begin{enumerate}
    \item \textbf{Importer} un fichier CSV de relations
    \item \textbf{Visualiser} le graphe de manière interactive
    \item \textbf{Appliquer} les algorithmes Louvain ou Girvan-Newman
    \item \textbf{Afficher} les statistiques et les communautés
    \item \textbf{Exporter} les résultats en PDF
\end{enumerate}

\section{Technologies Frontend}

\begin{itemize}
    \item \textbf{HTML5} : Structure de la page
    \item \textbf{CSS3} : Mise en forme (thème noir et blanc minimaliste)
    \item \textbf{JavaScript} : Logique applicative
    \item \textbf{Vis.js} : Visualisation interactive des graphes
    \item \textbf{html2pdf.js} : Export en PDF
\end{itemize}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.9\textwidth]{interface_screenshot.png}
    \fbox{\parbox{0.9\textwidth}{\centering\vspace{5cm}Capture d'écran de l'interface\\(À ajouter)\vspace{5cm}}}
    \caption{Interface web de l'application}
    \label{fig:interface}
\end{figure}

% ============================================================================
\chapter{Conclusion}
% ============================================================================

\section{Bilan}

Ce projet nous a permis de :

\begin{enumerate}
    \item Comprendre la \textbf{représentation de réseaux sociaux} sous forme de graphes
    \item Maîtriser deux algorithmes de \textbf{détection de communautés}
    \item Analyser les \textbf{forces et faiblesses} de chaque approche
    \item Développer une \textbf{application complète} (backend Python + frontend web)
    \item Pratiquer la \textbf{visualisation de données}
\end{enumerate}

\section{Comparaison Finale}

\begin{table}[H]
    \centering
    \caption{Synthèse comparative des algorithmes}
    \label{tab:synthese}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Critère} & \textbf{Louvain} & \textbf{Girvan-Newman} \\
        \hline
        Approche & Bottom-up & Top-down \\
        \hline
        Complexité & $O(n \log n)$ & $O(m^2 n)$ \\
        \hline
        Rapidité & Très rapide & Lent \\
        \hline
        Nb communautés & Automatique & À spécifier \\
        \hline
        Qualité (modularité) & Très bonne & Bonne \\
        \hline
        Grands graphes & Adapté & Non adapté \\
        \hline
    \end{tabular}
\end{table}

\section{Perspectives}

Pour améliorer ce projet, on pourrait :

\begin{itemize}
    \item Tester sur des \textbf{réseaux plus grands} (données réelles)
    \item Ajouter d'autres algorithmes (Label Propagation, Infomap, etc.)
    \item Implémenter des \textbf{graphes pondérés} (force des liens)
    \item Ajouter une \textbf{analyse temporelle} (évolution des communautés)
    \item Déployer l'application web sur un serveur
\end{itemize}

% ============================================================================
% ANNEXES
% ============================================================================
\appendix
\addcontentsline{toc}{chapter}{Annexes}

\chapter{Guide d'Installation}

\section{Prérequis}

\begin{itemize}
    \item Python 3.8 ou supérieur
    \item pip (gestionnaire de paquets Python)
\end{itemize}

\section{Installation}

\begin{lstlisting}[language=bash, caption=Commandes d'installation]
# Cloner le projet
git clone <url_du_projet>
cd Projet-Structure-15

# Creer un environnement virtuel
python -m venv .venv

# Activer l'environnement
source .venv/bin/activate  # Linux/Mac
# .venv\Scripts\activate   # Windows

# Installer les dependances
pip install -r requirements.txt
\end{lstlisting}

\section{Exécution}

\begin{lstlisting}[language=bash, caption=Lancement du programme]
# Executer le programme principal
python main.py

# Ou executer un module specifique
python src/louvain.py
python src/comparaison.py
\end{lstlisting}

\section{Interface Web}

\begin{lstlisting}[language=bash, caption=Lancement de l'interface web]
# Ouvrir directement dans le navigateur
# ou lancer un serveur local
cd interface
python -m http.server 8000

# Puis ouvrir http://localhost:8000
\end{lstlisting}

\chapter{Fichier requirements.txt}

\begin{lstlisting}[caption=Contenu de requirements.txt]
networkx>=3.0
pandas>=2.0
matplotlib>=3.7
python-louvain>=0.16
\end{lstlisting}

\chapter{Références}

\begin{enumerate}
    \item Blondel, V. D., Guillaume, J. L., Lambiotte, R., \& Lefebvre, E. (2008). \textit{Fast unfolding of communities in large networks}. Journal of Statistical Mechanics: Theory and Experiment.
    
    \item Girvan, M., \& Newman, M. E. (2002). \textit{Community structure in social and biological networks}. Proceedings of the National Academy of Sciences.
    
    \item Newman, M. E. (2006). \textit{Modularity and community structure in networks}. Proceedings of the National Academy of Sciences.
    
    \item Documentation NetworkX : \url{https://networkx.org/documentation/}
    
    \item Documentation python-louvain : \url{https://python-louvain.readthedocs.io/}
    
    \item Documentation Vis.js : \url{https://visjs.org/}
\end{enumerate}

\end{document}
